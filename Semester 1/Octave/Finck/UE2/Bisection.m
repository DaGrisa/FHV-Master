% author: Steffen Finck% support for lecture "Higher Mathematics 1"% Bisection for line search% Input:  x - starting point [Nx1]%         s - search direction [Nx1]%         fun - function providing function value and gradient%         rbound - value of step length for right interval bound (could be a guess)%         tol - tolerance for gradient (optional argument) default = 1e-10%         funopt - additional parameters for function call (optional argument) default = []% Output: alpha - final step size%         y - final point%         fy - function value at final point%         gy - gradient at final point [Nx1]%         stats - structure with some stats, see details within code% Note: use of structures to aggregate input and output informationfunction [alpha, y, fy, gy, stats] = Bisection(x, s, fun, rbound, tol, funopt)  % evaluate initial point  [fx,gx] = feval(fun,x,funopt);    % check whether rbound satisfies condition for right bound, i.e. g(rbound)â€™*s > 0   [frb, grb] = feval(fun,(x + rbound*s),funopt);  counter = 0;  lbound = 0; % left interval point is x, i.e. alpha = 0  while grb'*s < 0    lbound = rbound; % to initial interval as small as possible     rbound = rbound*2;    [frb, grb] = feval(fun,(x + rbound*s),funopt);    counter = counter + 1;    % safeguard    if counter > 100      error("Could not find point with positive gradient value!")     end  end  stats.funeval = 2 + counter; % count number of function evaluations  k = 1; % iteration counter  % search loop for minimizer  while rbound-lbound >= 2*sqrt(eps((rbound + lbound)/2)) % could be set to small fixed values    % stats    stats.intervallength(k) = rbound-lbound; % keep track of interval length    % create new point in the interval     alpha = (lbound + rbound)/2;    % evaluate point    y = x + alpha*s;    [fy,gy] = feval(fun,y,funopt);    % stats    stats.alpha(k) = alpha;     stats.funeval = stats.funeval + 1;     stats.dirgrad(k) = gy'*s/norm(s);    % check whether gradient at alpha satisfies tolerance or     % whether interval boundaries need to be updated    if stats.dirgrad(k) > tol      rbound = alpha;    elseif stats.dirgrad(k) < -tol      lbound = alpha;     else      disp("Bisection found optimal point!")      break;     end    k = k + 1;    % safeguard against too many iterations     if k > 100      disp("Bisection will not converge!")      break;     end  endend % of function