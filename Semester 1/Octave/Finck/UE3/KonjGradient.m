% author: Daniel Grießer % original: "Bisection for line search" by Steffen Finck% Input:  x - starting point [Nx1]%         s - search direction [Nx1]%         fun - function providing function value and gradient%         rbound - value of step length for right interval bound (could be a guess)%         tol - tolerance for gradient (optional argument) default = 1e-10%         funopt - additional parameters for function call (optional argument) default = []% Output: alpha - final step size%         y - final point%         fy - function value at final point%         gy - gradient at final point [Nx1]%         stats - structure with some stats, see details within code% Note: use of structures to aggregate input and output informationfunction [alpha, y, fy, gy, stats] = LineSearch(x, s, fun, rbound, tol, funopt, algorithm)  % evaluate initial point  [fx,gx] = feval(fun,x,funopt);    % check whether rbound satisfies condition for right bound, i.e. g(rbound)’*s > 0   [frb, grb] = feval(fun,(x + rbound*s),funopt);  counter = 0;  lbound = 0; % left interval point is x, i.e. alpha = 0  while grb'*s < 0    lbound = rbound; % to initial interval as small as possible     rbound = rbound*2;    [frb, grb] = feval(fun,(x + rbound*s),funopt);    counter = counter + 1;    % safeguard    if counter > 100      error("Could not find point with positive gradient value!")     end  end  stats.funeval = 2 + counter; % count number of function evaluations  k = 1; % iteration counter  % search loop for minimizer  while rbound-lbound >= 2*sqrt(eps((rbound + lbound)/2)) % could be set to small fixed values    % stats    stats.intervallength(k) = rbound-lbound; % keep track of interval length    % create new point in the interval     if algorithm == "RF"       alpha = RegulaFalsi(lbound, rbound, fun, funopt, x, s);    elseif algorithm == "PI"      alpha = PolynomInterpolation(lbound, rbound, fun, funopt, x, s);    else      error("Unknown algorithm! Use RF for Regula Falsi or PI for Polynomnterpolation.")     end % if        % evaluate point    y = x + alpha*s;    [fy,gy] = feval(fun,y,funopt);    % stats    stats.alpha(k) = alpha;     stats.funeval = stats.funeval + 1;     stats.dirgrad(k) = gy'*s/norm(s);    % check whether gradient at alpha satisfies tolerance or     % whether interval boundaries need to be updated    if stats.dirgrad(k) > tol      rbound = alpha;    elseif stats.dirgrad(k) < -tol      lbound = alpha;     else      disp("Line search found optimal point!")      break;     end    k = k + 1;    % safeguard against too many iterations     if k > 100      disp("Line search will not converge!")      break;     end  endend % of functionfunction [alpha] = RegulaFalsi(leftBound, rightBound, fun, funopt, x, s)  yLeftBound = x + leftBound*s;  [functionResultLeftBound,gradientResultLeftBound] = feval(fun,yLeftBound,funopt);  diffLeftBound = gradientResultLeftBound'*s/norm(s);    yRightBound = x + rightBound*s;  [functionResultRightBound,gradientResultRightBound] = feval(fun,yRightBound,funopt);  diffRightBound = gradientResultRightBound'*s/norm(s);    alpha = rightBound - diffRightBound * ((rightBound - leftBound) / (diffRightBound - diffLeftBound));end % of functionfunction [alpha] = PolynomInterpolation(leftBound, rightBound, fun, funopt, x, s)  yLeftBound = x + leftBound*s;  [functionResultLeftBound,gradientResultLeftBound] = feval(fun,yLeftBound,funopt);  diffLeftBound = gradientResultLeftBound'*s/norm(s);    yRightBound = x + rightBound*s;  [functionResultRightBound,gradientResultRightBound] = feval(fun,yRightBound,funopt);  diffRightBound = gradientResultRightBound'*s/norm(s);    A = [1, leftBound, leftBound^2, leftBound^3;      1, rightBound, rightBound^2, rightBound^3;      0, 1, 2*leftBound, 3*leftBound^2;      0, 1, 2*rightBound, 3*rightBound^2];    b = [functionResultLeftBound;      functionResultRightBound;      diffLeftBound;      diffRightBound];        c = A\b;    alpha = -(c(2)/(2*c(3))) - sqrt((c(2)^2/(9*c(3)^2))-(c(1)/3*c(3)));end % of function