/*
 * Os.c
 *
 *  Created on: 16. Dez. 2016
 *      Author: daniel
 */

#include <setjmp.h>
#include <msp430.h>

#define THREAD_ID_INVALID   -1

#define THREAD_STATUS_READY  0
#define THREAD_STATUS_RUN   1

#define THREAD_MAIN_PRIORITY    10

struct ProcessTableEntry {
    int threadId;
    // status of the process
    // 0 = sleep
    // 1 = run
    int status;
    // jump type?
    // 0 = set jump
    // 1 = long jump
    jmp_buf context;
    // process priority
    int priority;
    // process function pointer
    void* function;
};

void registerNewProcess(struct ProcessTableEntry entry);

void extendProcessTable();

// initialize process table with fixed size = 5
int numberOfProcesses = 0;
struct ProcessTableEntry processTable[5];

void boot(void *pMainProcess) {
    // keep main process in process table with low priority
    addProcess(pMainProcess, THREAD_MAIN_PRIORITY);
}

void addProcess(void *pProcessFunction, int priority) {
    struct ProcessTableEntry processTableEntry;
    processTableEntry.threadId = THREAD_ID_NOT_DEFINED;
    processTableEntry.status = THREAD_STATUS_READY;
    processTableEntry.priority = priority;
    processTableEntry.function = pProcessFunction;

    processTableEntry.threadId = registerNewProcess(processTableEntry);
}

int registerNewProcess(struct ProcessTableEntry entry) {
    // check process table size
    if(numberOfProcesses == sizeof(processTable)){
        extendProcessTable();
    }
    processTable[numberOfProcesses] = entry;
    numberOfProcesses++;
    return numberOfProcesses-1;
}

threadID scheduler_startThread(threadFunc tFunc) {
    __disable_interrupts();
    int newThread = THREAD_ID_INVALID;
    newThread = free thread slot gThreads[newThread].state = THREAD_READY;
    gThreads[newThread].threadFunc = tFunc;
    if (setjmp(gThreads[newThread].context) == 0) {
        // current context saved
     	__enable_interrupts();
        return newThread;
    } else {
        // running here as active Thread
        SP = allocate Stack (Pointer) ATOMIC_END(); gThread[gRunningThread].tFunc(); scheduler_killThread();
        return THREAD_ID_INVALID;
    }
