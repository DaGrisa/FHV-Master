/*
 * Os.c
 *
 *  Created on: 16. Dez. 2016
 *      Author: daniel
 */

#include <setjmp.h>
#include <msp430.h>

#define THREAD_ID_INVALID   -1

#define THREAD_STATUS_READY  0
#define THREAD_STATUS_RUN   1

#define THREAD_MAIN_PRIORITY    10

typedef int (*threadFunction)(int, int);

struct ProcessTableEntry {
    int threadId;
    // status of the process
    // 0 = sleep
    // 1 = run
    int status;
    // jump type?
    // 0 = set jump
    // 1 = long jump
    jmp_buf context;
    // process priority
    int priority;
    // process function pointer
    threadFunction function;
};

void registerNewProcess(struct ProcessTableEntry entry);

void extendProcessTable();

// initialize process table with fixed size = 5
int numberOfProcesses = 0;
struct ProcessTableEntry processTable[5];

void boot(void *pMainProcess) {
    // keep main process in process table with low priority
    addProcess(pMainProcess, THREAD_MAIN_PRIORITY);
}

void addProcess(void *pProcessFunction, int priority) {
    struct ProcessTableEntry processTableEntry;
    processTableEntry.status = THREAD_STATUS_READY;
    processTableEntry.priority = priority;
    processTableEntry.function = pProcessFunction;

    processTableEntry.threadId = registerNewProcess(processTableEntry);
    startThread(processTableEntry);
}

int registerNewProcess(struct ProcessTableEntry entry) {
    // check process table size
    if(numberOfProcesses == sizeof(processTable)){
        extendProcessTable();
    }
    processTable[numberOfProcesses] = entry;
    numberOfProcesses++;
    return numberOfProcesses-1;
}

int scheduler_startThread(struct ProcessTableEntry processTableEntry) {
    __disable_interrupts();
    if (setjmp(processTable[processTableEntry.threadId].context) == 0) {
        // current context saved
     	__enable_interrupts();
    } else {
        // running here as active Thread
        SP = allocate Stack (Pointer) ATOMIC_END(); gThread[gRunningThread].tFunc(); scheduler_killThread();
    }
