function [resultCode, overallBestCode] = GeneticProgrammingGrammaticalEvolution(grammar, genomeLength, maxRecursionDepth, referenceFunction, xValues, populationSize, crossoverProbability, mutationProbability, tournamentSize, maxGenerations)  populationGenomes = cell(1,genomeLength);  generationCount = 0;  overallBestCode = '';  overallBestFitness = Inf;    for i = 1:populationSize    populationGenomes(i) = getRandomGenome(genomeLength);  end  do    generationCount++;    populationGenomesChildren = cell(1,populationSize);    for j = 1:2:populationSize      firstChild = tournamentSelect(populationGenomes,tournamentSize, maxRecursionDepth, grammar, referenceFunction, xValues);      secondChild = tournamentSelect(populationGenomes,tournamentSize, maxRecursionDepth, grammar, referenceFunction, xValues);            if(firstChild.fitness < overallBestFitness)        overallBestFitness = firstChild.fitness;        overallBestCode = firstChild.programCode;      end      if(secondChild.fitness < overallBestFitness)        overallBestFitness = secondChild.fitness;        overallBestCode = secondChild.programCode;      end            if(rand() < crossoverProbability)        [populationGenomesChildren(j), populationGenomesChildren(j+1)] = crossover(firstChild.genome, secondChild.genome);      else        populationGenomesChildren(j) = firstChild.genome;        populationGenomesChildren(j+1) = secondChild.genome;      end    end    for k = 1:populationSize      populationGenomes(k) = mutate(cell2mat(populationGenomesChildren(k)),mutationProbability);    end  until generationCount >= maxGenerations;    resultCode = getResultCode(populationGenomes, maxRecursionDepth, grammar, referenceFunction, xValues);endfunction resultCode = getResultCode(populationGenomes, maxRecursionDepth, grammar, referenceFunction, xValues)  resultCode = '';  resultfitness = Inf;    populationSize = size(populationGenomes,2);  for i = 1:populationSize    codons = genome2Codons(cell2mat(populationGenomes(i)));    if(size(codons,1)>0) % TODO bound error?      programCode = getProgramCode(codons, maxRecursionDepth, grammar);      fitness = evaluateFitness(programCode, referenceFunction, xValues);    end        if(fitness <= resultfitness)      resultfitness = fitness;         resultCode = programCode;    end  endend;function genome = mutate(genome, mutationProbability)  genomeSize = size(genome,2);  for i = 1:genomeSize    if(rand() < mutationProbability) % flip single bit      if(genome(i)==1)        genome(i) = 0;      else        genome(i) = 1;      end    end  endendfunction [firstGenomeResult, secondGenomeResult] = crossover(firstGenome, secondGenome)   length = size(firstGenome,2);  randomCrossoverIndex = round(rand()*length);    firstGenomeResult = [firstGenome(1:randomCrossoverIndex),secondGenome((randomCrossoverIndex+1):end)];  secondGenomeResult = [secondGenome(1:randomCrossoverIndex),firstGenome((randomCrossoverIndex+1):end)];endfunction child = tournamentSelect(populationGenomes,tournamentSize, maxRecursionDepth, grammar, referenceFunction, xValues)  populationGenomesSize = size(populationGenomes,1);  bestFitness = Inf;  for i = 1:tournamentSize    randomIndex = floor(populationGenomesSize*rand())+1;        codons = genome2Codons(cell2mat(populationGenomes(randomIndex)));    programCode = getProgramCode(codons, maxRecursionDepth, grammar);    fitness = evaluateFitness(programCode, referenceFunction, xValues);        if(fitness <= bestFitness)      bestFitness = fitness;         child.genome = cell2mat(populationGenomes(randomIndex));      child.fitness = fitness;      child.programCode = programCode;    end  endendfunction fitness = evaluateFitness(programCode, referenceFunction, xValues)  fitness = 0;  programCodeWithVariable = strcat('result=',programCode,';');  for i = 1:size(xValues,1)    x = xValues(i);    eval(programCodeWithVariable, 'result=Inf;');    fitnessDifference = abs(feval(referenceFunction,x) - result);    fitness += fitnessDifference;  end    if(isnan(fitness))    fitness = Inf;  endendfunction programCode = getProgramCode(codons, maxRecursionDepth, grammar)  currentRecursionDepth = 1;  currentCodonIndex = 1;  syntaxTree.value = 'root';  syntaxTree.children = getExpression(codons, currentCodonIndex, currentRecursionDepth, maxRecursionDepth, grammar);  programCode = convert2ProgramCode(syntaxTree);endfunction programCode = convert2ProgramCode(syntaxTree)  programCode = '';  childrenCount = size(syntaxTree.children,1);  if(childrenCount>0)    for i = 1:childrenCount      programCode = strcat(programCode, convert2ProgramCode(syntaxTree.children(i)));    end  else    programCode = syntaxTree.value;  end;endfunction genome = getRandomGenome(length)  genome = [];  for i = 1:length    genome(i) = round(rand());  endend              function codons = genome2Codons(genome)  genomeLength = size(genome,2);  codons = [];  codonsIndex = 1;  for i = 1:8:genomeLength    endIndex = i+7;    if(endIndex > genomeLength)      endIndex = genomeLength;    end    newCodon = bin2dec(int2str(genome(i:endIndex)));    codons(codonsIndex++) = newCodon;  end  codons = codons';end              function syntaxTreeChildren = resolveNonTerminals(nonTerminalsString, codons, currentCodonIndex, currentRecursionDepth, maxRecursionDepth, grammar)  syntaxTreeChildren = [];  nonTerminals = strsplit(nonTerminalsString{1},';')';  for i = 1:size(nonTerminals,1)    nonTerminal = nonTerminals{i};    codonsIndex = mod(currentCodonIndex++,size(codons,1))+1;        switch(nonTerminal)      case 'expression'        syntaxTreeChildren = [syntaxTreeChildren ; getExpression(codons, currentCodonIndex, ++currentRecursionDepth, maxRecursionDepth, grammar)];      case 'operation'        syntaxTreeChildren = [syntaxTreeChildren ; getOperationTerminal(codons(codonsIndex), grammar)];      case 'preoperation'        syntaxTreeChildren = [syntaxTreeChildren ; getPreOperationTerminal(codons(codonsIndex), grammar)];      case 'variable'        syntaxTreeChildren = [syntaxTreeChildren ; getVariable(codons(codonsIndex), grammar)];      case 'number'        syntaxTreeChildren = [syntaxTreeChildren ; getNumber(codons(codonsIndex), grammar)];      otherwise        syntaxTreeNode.value = nonTerminal;        syntaxTreeNode.children = [];        syntaxTreeNode.replaceable = false;        syntaxTreeChildren = [syntaxTreeChildren ; syntaxTreeNode];  endswitch  endendfunction syntaxTreeChildren = getExpression(codons, currentCodonIndex, currentRecursionDepth, maxRecursionDepth, grammar)  codonsIndex = mod(currentCodonIndex++,size(codons,1))+1;  if(++currentRecursionDepth >= maxRecursionDepth)    syntaxTreeNode.value = getNumber(codons(codonsIndex),grammar).value;    syntaxTreeNode.children = [];    syntaxTreeNode.replaceable = true;  else    arraySize = size(grammar.expressions,1);    arrayIndex = mod(codons(codonsIndex),arraySize) +1;    expression = grammar.expressions(arrayIndex);    syntaxTreeNode.value = 'expression';    syntaxTreeNode.children = resolveNonTerminals(expression, codons, currentCodonIndex, ++currentRecursionDepth, maxRecursionDepth, grammar);    syntaxTreeNode.replaceable = true;  end    syntaxTreeChildren = [syntaxTreeNode];endfunction syntaxTreeChildren = getVariable(randomIndex, grammar)  arraySize = size(grammar.variables,1);  arrayIndex = mod(randomIndex,arraySize)+1;  variable = grammar.variables(arrayIndex);  syntaxTreeNode.value = variable;  syntaxTreeNode.children = [];  syntaxTreeNode.replaceable = true;  syntaxTreeChildren = [syntaxTreeNode];endfunction syntaxTreeChildren = getOperationTerminal(randomIndex, grammar)  arraySize = size(grammar.operationTerminals,1);  arrayIndex = mod(randomIndex,arraySize)+1;  operationTerminal = grammar.operationTerminals(arrayIndex);  syntaxTreeNode.value = operationTerminal;  syntaxTreeNode.children = [];  syntaxTreeNode.replaceable = true;  syntaxTreeChildren = [syntaxTreeNode];endfunction syntaxTreeChildren = getPreOperationTerminal(randomIndex, grammar)  arraySize = size(grammar.preOperationTerminals,1);  arrayIndex = mod(randomIndex,arraySize)+1;  preOperationTerminal = grammar.preOperationTerminals(arrayIndex);  syntaxTreeNode.value = preOperationTerminal;  syntaxTreeNode.children = [];  syntaxTreeNode.replaceable = true;  syntaxTreeChildren = [syntaxTreeNode];endfunction syntaxTreeChildren = getNumber(randomIndex, grammar)  arraySize = size(grammar.numbers,1);  arrayIndex = mod(randomIndex,arraySize)+1;  number = grammar.numbers(arrayIndex);  syntaxTreeNode.value = number;  syntaxTreeNode.children = [];  syntaxTreeNode.replaceable = true;  syntaxTreeChildren = [syntaxTreeNode];end