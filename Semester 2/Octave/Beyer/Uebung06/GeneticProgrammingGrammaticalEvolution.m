function GeneticProgrammingGrammaticalEvolution(grammar, genomeLength, maxRecursionDepth, referenceFunction, xValues, populationSize, crossoverProbability, mutationProbability, tournamentSize, maxGenerations)  populationGenomes = [];  generationCount = 0;    for i = 1:populationSize    populationGenomes(i) = getRandomGenome(genomeLength);  end  do    generationCount++;    populationGenomesChildren = [];    for j = 1:2:populationSize      firstChild = tournamentSelect(populationGenomes,tournamentSize, maxRecursionDepth, grammar, referenceFunction, xValues);      secondChild = tournamentSelect(populationGenomes,tournamentSize, maxRecursionDepth, grammar, referenceFunction, xValues);      if(rand() < crossoverProbability)        [populationGenomesChildren(j), populationGenomesChildren(j+1)] = crossover(firstChild, secondChild);      else        populationGenomesChildren(j) = firstChild;        populationGenomesChildren(j+1) = secondChild;      end    end    for k = 1:populationSize      populationGenomes(k) = mutate(populationGenomesChildren(k),mutationProbability);    end  until generationCount >= maxGenerations;endfunction [firstChildResult, secondChildResult] = crossover(firstChild, secondChild)  [firstChild,firstChildSwap] = getRandomChildNode(firstChild);  [secondChild,secondChildSwap] = getRandomChildNode(secondChild);    firstChildResult = setRandomChildNode(firstChild, secondChildSwap);  secondChildResult = setRandomChildNode(secondChild, firstChildSwap);end;function [syntaxTree,treeNode] = getRandomChildNode(syntaxTree)  childrenSize = size(syntaxTree.children,1);  if(childrenSize>0)    for l = 1:childrenSize      child = syntaxTree.children(l);      if(child.replaceable)        if(rand() < 0.5)          treeNode = child;          child.value = 'exchange';          child.children = [];          child.replaceable = true;          break;        end      end      [child, treeNode] = getRandomChildNode(child);    end  else    treeNode = syntaxTree;    syntaxTree.value = 'exchange';    syntaxTree.children = [];    syntaxTree.replaceable = true;  endendfunction syntaxTree = setRandomChildNode(syntaxTree, treeNode)  childrenSize = size(syntaxTree.children,1);  if(childrenSize>0)    for l = 1:childrenSize      child = syntaxTree.children(l);      if(strcmp(child.value,'exchange'))        child = treeNode;        break;      end      syntaxTree = setRandomChildNode(child, treeNode);    end  else    if(strcmp(child.value,'exchange'))      child = treeNode;    end  endendfunction child = tournamentSelect(populationGenomes,tournamentSize, maxRecursionDepth, grammar, referenceFunction, xValues)  populationGenomesSize = size(populationGenomes,1);  bestFitness = Inf;  child = [];  for i = 1:tournamentSize    randomIndex = floor(populationGenomesSize*rand())+1;        codons = genome2Codons(populationGenomes(randomIndex));    programCode = getProgramCode(codons, maxRecursionDepth, grammar);    fitness = evaluateFitness(programCode, referenceFunction, xValues);        if(fitness < bestFitness)      bestFitness = fitness;      populationGenomes(randomIndex);      child = evaluateFitness(programCode, referenceFunction, xValues);    end  endendfunction fitness = evaluateFitness(programCode, referenceFunction, xValues)  fitness = 0;  programCodeWithVariable = strcat('result=',programCode,';');  for i = 1:size(xValues,1)    x = xValues(i);    eval(programCodeWithVariable, 'result=Inf;');    fitnessDifference = abs(feval(referenceFunction,x) - result);    fitness += fitnessDifference;  end    if(isnan(fitness))    fitness = Inf;  endendfunction programCode = getProgramCode(codons, maxRecursionDepth, grammar)  currentRecursionDepth = 1;  currentCodonIndex = 1;  syntaxTree.value = 'root';  syntaxTree.children = getExpression(codons, currentCodonIndex, currentRecursionDepth, maxRecursionDepth, grammar);  programCode = convert2ProgramCode(syntaxTree);endfunction programCode = convert2ProgramCode(syntaxTree)  programCode = '';  childrenCount = size(syntaxTree.children,1);  if(childrenCount>0)    for i = 1:childrenCount      programCode = strcat(programCode, convert2ProgramCode(syntaxTree.children(i)));    end  else    programCode = syntaxTree.value;  end;endfunction genome = getRandomGenome(length)  genome = [];  for i = 1:length    genome(i) = round(rand());  endend              function codons = genome2Codons(genome)  genomeLength = size(genome,2);  codons = [];  codonsIndex = 1;  for i = 1:8:genomeLength    endIndex = i+7;    if(endIndex > genomeLength)      endIndex = genomeLength;    end    newCodon = bin2dec(int2str(genome(i:endIndex)));    codons(codonsIndex++) = newCodon;  end  codons = codons';end              function syntaxTreeChildren = resolveNonTerminals(nonTerminalsString, codons, currentCodonIndex, currentRecursionDepth, maxRecursionDepth, grammar)  syntaxTreeChildren = [];  nonTerminals = strsplit(nonTerminalsString{1},';')';  for i = 1:size(nonTerminals,1)    nonTerminal = nonTerminals{i};    codonsIndex = mod(currentCodonIndex++,size(codons,1))+1;        switch(nonTerminal)      case 'expression'        syntaxTreeChildren = [syntaxTreeChildren ; getExpression(codons, currentCodonIndex, ++currentRecursionDepth, maxRecursionDepth, grammar)];      case 'operation'        syntaxTreeChildren = [syntaxTreeChildren ; getOperationTerminal(codons(codonsIndex), grammar)];      case 'preoperation'        syntaxTreeChildren = [syntaxTreeChildren ; getPreOperationTerminal(codons(codonsIndex), grammar)];      case 'variable'        syntaxTreeChildren = [syntaxTreeChildren ; getVariable(codons(codonsIndex), grammar)];      case 'number'        syntaxTreeChildren = [syntaxTreeChildren ; getNumber(codons(codonsIndex), grammar)];      otherwise        syntaxTreeNode.value = nonTerminal;        syntaxTreeNode.children = [];        syntaxTreeNode.replaceable = false;        syntaxTreeChildren = [syntaxTreeChildren ; syntaxTreeNode];  endswitch  endendfunction syntaxTreeChildren = getExpression(codons, currentCodonIndex, currentRecursionDepth, maxRecursionDepth, grammar)  codonsIndex = mod(currentCodonIndex++,size(codons,1))+1;  if(++currentRecursionDepth >= maxRecursionDepth)    syntaxTreeNode.value = getNumber(codons(codonsIndex),grammar).value;    syntaxTreeNode.children = [];    syntaxTreeNode.replaceable = true;  else    arraySize = size(grammar.expressions,1);    arrayIndex = mod(codons(codonsIndex),arraySize) +1;    expression = grammar.expressions(arrayIndex);    syntaxTreeNode.value = 'expression';    syntaxTreeNode.children = resolveNonTerminals(expression, codons, currentCodonIndex, ++currentRecursionDepth, maxRecursionDepth, grammar);    syntaxTreeNode.replaceable = true;  end    syntaxTreeChildren = [syntaxTreeNode];endfunction syntaxTreeChildren = getVariable(randomIndex, grammar)  arraySize = size(grammar.variables,1);  arrayIndex = mod(randomIndex,arraySize)+1;  variable = grammar.variables(arrayIndex);  syntaxTreeNode.value = variable;  syntaxTreeNode.children = [];  syntaxTreeNode.replaceable = true;  syntaxTreeChildren = [syntaxTreeNode];endfunction syntaxTreeChildren = getOperationTerminal(randomIndex, grammar)  arraySize = size(grammar.operationTerminals,1);  arrayIndex = mod(randomIndex,arraySize)+1;  operationTerminal = grammar.operationTerminals(arrayIndex);  syntaxTreeNode.value = operationTerminal;  syntaxTreeNode.children = [];  syntaxTreeNode.replaceable = true;  syntaxTreeChildren = [syntaxTreeNode];endfunction syntaxTreeChildren = getPreOperationTerminal(randomIndex, grammar)  arraySize = size(grammar.preOperationTerminals,1);  arrayIndex = mod(randomIndex,arraySize)+1;  preOperationTerminal = grammar.preOperationTerminals(arrayIndex);  syntaxTreeNode.value = preOperationTerminal;  syntaxTreeNode.children = [];  syntaxTreeNode.replaceable = true;  syntaxTreeChildren = [syntaxTreeNode];endfunction syntaxTreeChildren = getNumber(randomIndex, grammar)  arraySize = size(grammar.numbers,1);  arrayIndex = mod(randomIndex,arraySize)+1;  number = grammar.numbers(arrayIndex);  syntaxTreeNode.value = number;  syntaxTreeNode.children = [];  syntaxTreeNode.replaceable = true;  syntaxTreeChildren = [syntaxTreeNode];end