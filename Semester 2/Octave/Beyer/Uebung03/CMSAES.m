function [fitnessHistory, sigmaHistory, fitnessParent, generationCount, functionEvaluationCount, fitnessHistoryFunctionEvaluation, sigmaNormHistory, yHistory] = CMSAES(yParent, sigmaParent, sigmaStop, offspringPopulationSize, parentPopulationSize, targetFunction, searchPath, searchPathConstant, attenuation, maxGenerations, covarianceConstant, evolutionPathConstant, evolutionPath, covarianceMatrix)  % initialization  dimensions = size(yParent, 1);    fitnessHistory = [feval(targetFunction, yParent)];  fitnessHistoryFunctionEvaluation = fitnessHistory;  yHistory = [yParent'];  sigmaHistory = [sigmaParent];  sigmaNormHistory = [];    generationCount = 0;  functionEvaluationCount = 1;    %randn("state", 7); % random settings only valid in same scope    do    % empty pools    fitnessPool = [];    childrenPool = [];        matrix = chol(covarianceMatrix)'; % Cholesky Zerlegung - Eigenwertproblem    % [u, gamma] = eig(covarianceMatrix);    % matrix = u * sqrt(gamma) * u';        % generate offspring    for i = 1:offspringPopulationSize      child.sigma = sigmaParent;            mutation = randn(dimensions, 1);      child.mutation = mutation;            correlatedSearchDirectionLambda = matrix * mutation;      child.correlatedSearchDirection = correlatedSearchDirectionLambda;            yLambda = yParent + correlatedSearchDirectionLambda * sigmaParent;      child.y = yLambda;            childrenPool = [childrenPool ; child];            fitnessLambda = feval(targetFunction, yLambda);      functionEvaluationCount++;      fitnessHistoryFunctionEvaluation = [fitnessHistoryFunctionEvaluation ; fitnessLambda];      fitnessPool = [fitnessPool ; fitnessLambda];    end            % recombine best individuals    mutationPool = [];    correlatedSearchDirectionPool = [];        for j = 1:parentPopulationSize      % choose best child      minFitness = min(fitnessPool);      indexBestChild = find(fitnessPool == minFitness);            % set best value to infinite      fitnessPool(indexBestChild) = inf;            % save values into pools      mutationChild = childrenPool(indexBestChild).mutation;      mutationPool = [mutationPool ; mutationChild'];      correlatedSearchDirectionChild = childrenPool(indexBestChild).correlatedSearchDirection;      correlatedSearchDirectionPool = [correlatedSearchDirectionPool ; correlatedSearchDirectionChild'];    end        % recombine mutations    mutationParent = MeanCalc(mutationPool)';    correlatedSearchDirectionParent = MeanCalc(correlatedSearchDirectionPool)';        yParent = yParent + sigmaParent * correlatedSearchDirectionParent;    if(size(yParent,1) != dimensions)      size(yParent,1)      error("yParent wrong dimensions!");    end    yHistory = [yHistory ; yParent'];        fitnessParent = feval(targetFunction, yParent);    fitnessHistory = [fitnessHistory ; fitnessParent];        evolutionPath = (1 - evolutionPathConstant) * evolutionPath + sqrt(parentPopulationSize * evolutionPathConstant * (2 - evolutionPathConstant)) * correlatedSearchDirectionParent;    covarianceMatrix = (1 - covarianceConstant) * covarianceMatrix + covarianceConstant * ((1/offspringPopulationSize) * evolutionPath * evolutionPath' + (1-1/offspringPopulationSize) * correlatedSearchDirectionParent * correlatedSearchDirectionParent');        searchPath = (1 - searchPathConstant) * searchPath + sqrt(parentPopulationSize * searchPathConstant * (2 - searchPathConstant)) * mutationParent;    expectedValueXi = sqrt(dimensions) * (1 - dimensions^(-1) / 4 + dimensions^(-2) / 21);    sigmaParent = sigmaParent * exp((norm(searchPath) - expectedValueXi)/(attenuation * expectedValueXi));    sigmaHistory = [sigmaHistory ; sigmaParent];        sigmaNorm = sigmaParent * dimensions / sqrt(fitnessParent);    sigmaNormHistory = [sigmaNormHistory ; sigmaNorm];        generationCount++;  until sigmaParent < sigmaStop || generationCount == maxGenerations;end