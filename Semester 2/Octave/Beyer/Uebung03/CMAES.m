function [stats, fitnessParent] = CMAES(yParent, sigmaParent, sigmaStop, offspringPopulationSize, parentPopulationSize, targetFunction, searchPath, searchPathConstant, attenuation, maxGenerations, covarianceConstant, evolutionPathConstant, evolutionPath, covarianceMatrix)  % initialization  dimensions = size(yParent, 1);    fitnessHistory = [feval(targetFunction, yParent)];  fitnessHistoryFunctionEvaluation = fitnessHistory;  yHistory = [yParent'];  sigmaHistory = [sigmaParent];  sigmaNormHistory = [];    generationCount = 0;  functionEvaluationCount = 1;    %randn("state", 7); % random settings only valid in same scope    do    % empty pools    fitnessPool = [];    childrenPool = [];    generationCount++;        matrix = chol(covarianceMatrix)'; % Cholesky Zerlegung - Eigenwertproblem    [u, gamma] = eig(covarianceMatrix);    matrix = u * sqrt(gamma) * u';    eigValues = diag(gamma);    stats.maxEigValues(generationCount) = max(eigValues);    stats.minEigValues(generationCount) = min(eigValues);    stats.relationMaxMinEigValues(generationCount) = max(eigValues)/min(eigValues);        % generate offspring    for i = 1:offspringPopulationSize      child.sigma = sigmaParent;            mutation = randn(dimensions, 1);      child.mutation = mutation;            correlatedSearchDirectionLambda = matrix * mutation;      child.correlatedSearchDirection = correlatedSearchDirectionLambda;            yLambda = yParent + correlatedSearchDirectionLambda * sigmaParent;      child.y = yLambda;            childrenPool = [childrenPool ; child];            fitnessLambda = feval(targetFunction, yLambda);      functionEvaluationCount++;      fitnessHistoryFunctionEvaluation = [fitnessHistoryFunctionEvaluation ; fitnessLambda];      fitnessPool = [fitnessPool ; fitnessLambda];    end            % recombine best individuals    mutationPool = [];    correlatedSearchDirectionPool = [];        for j = 1:parentPopulationSize      % choose best child      minFitness = min(fitnessPool);      indexBestChild = find(fitnessPool == minFitness);            % set best value to infinite      fitnessPool(indexBestChild) = inf;            % save values into pools      mutationChild = childrenPool(indexBestChild).mutation;      mutationPool = [mutationPool ; mutationChild'];      correlatedSearchDirectionChild = childrenPool(indexBestChild).correlatedSearchDirection;      correlatedSearchDirectionPool = [correlatedSearchDirectionPool ; correlatedSearchDirectionChild'];    end        % recombine mutations    mutationParent = MeanCalc(mutationPool)';    correlatedSearchDirectionParent = MeanCalc(correlatedSearchDirectionPool)';        yParent = yParent + sigmaParent * correlatedSearchDirectionParent;    if(size(yParent,1) != dimensions)      size(yParent,1)      error("yParent wrong dimensions!");    end    yHistory = [yHistory ; yParent'];        fitnessParent = feval(targetFunction, yParent);    fitnessHistory = [fitnessHistory ; fitnessParent];        evolutionPath = (1 - evolutionPathConstant) * evolutionPath + sqrt(parentPopulationSize * evolutionPathConstant * (2 - evolutionPathConstant)) * correlatedSearchDirectionParent;    covarianceMatrix = (1 - covarianceConstant) * covarianceMatrix + covarianceConstant * evolutionPath * evolutionPath';        searchPath = (1 - searchPathConstant) * searchPath + sqrt(parentPopulationSize * searchPathConstant * (2 - searchPathConstant)) * mutationParent;    expectedValueXi = sqrt(dimensions) * (1 - dimensions^(-1) / 4 + dimensions^(-2) / 21);    sigmaParent = sigmaParent * exp((norm(searchPath) - expectedValueXi)/(attenuation * expectedValueXi));    sigmaHistory = [sigmaHistory ; sigmaParent];        sigmaNorm = sigmaParent * dimensions / sqrt(fitnessParent);    sigmaNormHistory = [sigmaNormHistory ; sigmaNorm];until sigmaParent < sigmaStop || generationCount == maxGenerations;    stats.fitnessHistory = fitnessHistory;  stats.sigmaHistory = sigmaHistory;  stats.generationCount = generationCount;  stats.functionEvaluationCount = functionEvaluationCount;  stats.fitnessHistoryFunctionEvaluation = fitnessHistoryFunctionEvaluation;  stats.sigmaNormHistory = sigmaNormHistory;  stats.yHistory = yHistory;  end