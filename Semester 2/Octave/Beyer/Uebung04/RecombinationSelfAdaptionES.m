function [yParent, fitnessParent, stats] = RecombinationSelfAdaptionES(yParent, sigmaParent, sigmaStop, offspringPopulationSize, parentPopulationSize, tau, targetFunction, maxGenerations, desiredFitness)  % initialization  dimensions = size(yParent, 1);    fitnessHistory = [feval(targetFunction, yParent)];  fitnessHistoryFunctionEvaluation = fitnessHistory;  y2History = [(yParent.*yParent)'];  sigmaHistory = [sigmaParent];  sigmaNormHistory = [];    generationCount = 0;  functionEvaluationCount = 1;  successfulRuns = 0;    fitnessParent = Inf;    %randn("state", 7); % random settings only valid in same scope    do    % empty pools    fitnessPool = [];    childrenPool = [];        % generate offspring    for i = 1:offspringPopulationSize      xi = e^(tau*randn(1));      sigmaLambda = sigmaParent * xi;      child.sigma = sigmaLambda;            mutation = randn(dimensions, 1);      yLambda = yParent + mutation * sigmaLambda;      child.y = yLambda;            childrenPool = [childrenPool ; child];            fitnessLambda = feval(targetFunction, yLambda);      functionEvaluationCount++;      fitnessHistoryFunctionEvaluation = [fitnessHistoryFunctionEvaluation ; fitnessLambda];      fitnessPool = [fitnessPool ; fitnessLambda];            if(fitnessLambda < fitnessParent)        successfulRuns++;      end    end            % recombine best individuals    sigmaPool = [];    yPool = [];        for i = 1:parentPopulationSize      % choose best child      minFitness = min(fitnessPool);      indexBestChild = find(fitnessPool == minFitness);            % set best value to infinite      fitnessPool(indexBestChild) = inf;            % save values into pools      sigmaChild = childrenPool(indexBestChild).sigma;      sigmaPool = [sigmaPool ; sigmaChild];      yChild = childrenPool(indexBestChild).y;      yPool = [yPool ; yChild'];    end        % set new parent values    sigmaParent = MeanCalc(sigmaPool);    sigmaHistory = [sigmaHistory ; sigmaParent];        yParent = MeanCalc(yPool)';    if(size(yParent,1) != dimensions)      size(yParent,1)      error("yParent wrong dimensions!");    end    y2History = [y2History ; (yParent.*yParent)'];        fitnessParent = feval(targetFunction, yParent);    fitnessHistory = [fitnessHistory ; fitnessParent];        sigmaNorm = sigmaParent * dimensions / sqrt(fitnessParent);    sigmaNormHistory = [sigmaNormHistory ; sigmaNorm];            generationCount++;  until sigmaParent < sigmaStop || generationCount == maxGenerations || fitnessParent <= desiredFitness;    stats.fitnessHistory = fitnessHistory;  stats.sigmaHistory = sigmaHistory;  stats.generationCount = generationCount;  stats.functionEvaluationCount = functionEvaluationCount;  stats.fitnessHistoryFunctionEvaluation = fitnessHistoryFunctionEvaluation;  stats.sigmaNormHistory = sigmaNormHistory;  stats.y2History = y2History;  stats.successfulRuns = successfulRuns;end